# 189. 轮转数组

## 思路

## 题目

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

## 示例

### 示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

### 示例 2:

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]

## 分析解题

轮转数组，可以把最后一个放在一个temp，再把整个数组向后移动一位，之后吧最后一个数组再放回第一位。循环这个过程，轮转次就循环几次：

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        for(int i = 0;i < k;i++){
            int temp = nums[nums.size() - 1];

            // 从后往前放
            for(int a = nums.size() - 1;a > 0;a--){
                nums[a] = nums[a - 1];
            }
            nums[0] = temp;
        }
    }
};
```

这样可以通过，但时间复杂度太大，进行了两个循环。

当数组较大的时候，在leetcode上面会超出时间限制。

我门再想一想，发现如果轮转数k是1，那么最后一个数字就在0的位置，倒数第二个数字在最后一个位置。

轮转数为2的时候，最后一个数字在1的位置，倒数第二个在0的位置。

貌似轮转数与数字变化之后的位置有一定的线性关系。

所以我们可以不使用两次循环，直接把数字放到它自己的位置。

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        
        // 将后 k 个元素保存到辅助数组中
        vector<int> temp(nums.begin() + n - k, nums.end());
        
        // 将剩余的元素向后移动 k 位
        for (int i = n - 1; i >= k; --i) {
            nums[i] = nums[i - k];
        }
        
        // 将辅助数组的元素放到前 k 个位置上
        for (int i = 0; i < k; ++i) {
            nums[i] = temp[i];
        }
    }
};
```