# C++复习-3

## 宏函数

频繁调用的小函数可以使用宏函数：

```cpp
#define ADD(a,b) ((a) + (b))
```

宏函数不可以加分号，因为分号是代表一个句子的结束,当加分号之后：

```cpp
#define ADD(a,b) ((a) + (b));
int ret = ADD(1,2); //这里不会报错
cout << ADD(1,2) << endl; //这里会报错
```

不会报错是因为这里相当于在ADD()之后有两个分号。

报错是因为这里相当于在`<<`之前有一个分号，想当于下面这样：

```cpp
cout << ADD(1,2); << endl;
```

所以下面在输出ADD的时候就会报错。故在定义宏函数的时候不可以在结尾添加分号。

为什么要加里面的括号，我们举例一个不传里面括号的表达式：

```cpp
#define ADD(a,b) (a + b)
ADD(x&y,x|y);
```

这里的相当于`ADD(x&y+x|y)`因为加号的优先级更高，故这里达不到我们想要的效果，所以在里面要加括号。

宏函数的优点：
1. 增强代码的复用性。
2. 提高运行的性能。
3. 
缺点：
1. 不方便调试宏函数，因为在预编译阶段进行了替换。
2. 导致代码可读性变差，可维护性差，容易误用。
3. 没有安全检查机制

可以使用常量定义，换用`const enum`

也可以将短小函数换用内联函数。

## 内联函数

内联函数与宏函数类似，是在调用的时候展开。

但是当函数比较大的时候，使用inline的内联函数不会展开。

内联函数不可以声明和定义分离。会产生链接错误。

## auto

自动推导类型，通过右边的赋值自动推导类型：

```cpp
ing j = 0;
auto i = 0;
```

auto主要在使用迭代器等内容的时候会十分有用。auto可以替代比较长的类型定义，简化代码。

`typeid(x).name()`可以输出一个对象的类型。

auto不可以在同一行定义，下面这种写法是错误的：

```cpp
auto a = 1,b = 2;
```

CPP支持使用auto遍历数组：

```cpp
for (auto i : array){
    //..
}
```

可以自动取array中的值放入i中。这个遍历数组的方法是CPP学习借鉴python的，JAVA中的这种方法也是借鉴python的。

## NULL
C++中可以在宏定义的时候将NULL定义为0：

```cpp
#define NULL 0
```

但是在进行这样的宏定义之后，NULL就不再是一个指针了，C++为了解决这个问题，引入了一个新的关键字`nullptr`。

`nullptr`在使用的时候表示空指针，不需要再包含任何头文件。

在C++11中，sizeof(nullptr)和sizeof((void*)0)是一样的大小。