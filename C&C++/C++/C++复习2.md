# C++复习-2

## 函数重载

C语言不允许同名函数的存在。

C++可以支持同名函数，及下面这段代码在C中是会报错的，但是在C++中可以正常运行。

```cpp
void Swap(int * a);
void Swap(double * a);
```

C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数、类型或类型顺序)不同。

注意返回值不同并不能区分两个函数的调用，故也不能满足重载。

而下面会构成重载，但是调用会产生歧义：

```cpp
void f();
void f(int a = 0);
```

调用歧义是调用歧义，函数重载是函数重载。这里产生调用歧义，但满足函数重载，参数个数不同。在编程时要尽量避免。

为什么C++会支持重载，而C语言不会支持重载呢？

编译的过程：
Stack.h Stack.cpp Test.cpp
1. 预处理：展开头文件/宏替换/条件编译 Stack.i Test.i
2. 编译：检查语法、生成汇编代码 Stack.s Test.s
3. 汇编：将汇编代码转化为二进制的机器码 Stack.o Test.o
4. 链接：生成可执行程序 xxx.exe a.out

函数有一堆需要执行的指令，函数的地址是第一句指令的地址。

在编译的时候，先有函数的声明，如果坚持语法没错就会出现声明，没有函数的地址。函数的地址需要在定义的时候知道。及在Test.cpp中有函数的声明，但是函数的地址在出现Stack.o的时候才会出现。而链接后，将Test.o和Stack.o的声明和地址联系在一起。在Test.o中会有符号表，及函数名和地址的映射，方便在链接的时候查找。

当链接的时候，为声明找不到地址，则会产生链接错误。

讲了在链接的时候，将声明和定义匹配的过程。也就明白为什么C语言不支持重载了。

C语言是在使用函数名称直接查找，故不支持重载。

而C++是通过修饰后的函数名查找，函数名的修饰规则，是将参数的类型也作为函数名的一部分，这样在链接的时候就可以将参数不同函数的声明和定义匹配在一起，实现函数的重构。

不同的编译器的修饰规则不同。

## 引用

引用就是取别名。

```cpp
int a = 0;
int &b = a;
```

这里的b就是a的引用。

在函数传入参数的时候，可以传入引用。防止形参实参的问题。

我们不只可以给整型取别名，也可以给指针取别名：

```cpp
int x = 0;
int * b = &x;
int * &a = b;
```

引用在定义的时候必须要初始化，一个变量可以创建多个应用。

引用一但指向一个实体。就不能再指向其他的实体。

```cpp
const int m = 0;
int & n = m;
```

这里是会报错的，关系到权限的放大。const指定后权限是可读不可写的，但是这里的引用是可读可写的。所以会报错。

```cpp
const int m = 0;
const int & n = m;
```

这里的权限的平移，是合理的，符合语法规则。

```cpp
int m = 0;
const int &n = m;
```

这里的权限的缩小，自然也是合理的。

```cpp
const int* p1 = &m;
p1++; //合理
int *p2 = p1; //错误
```

指针也存在权限的放大，这里的const修饰的是`*p1`p1的地址，就是p1的地址是无法修改的，但是p1的值是可以修改的，所以这里可以p1++。

这里一定要注意：

```cpp
const int a = 0;
int b = a;
```

这里不涉及权限的放大，因为是把a拷贝给b，引用有权限的放大，指针也有权限的放大，但是普通的变量没有权限的放大。

没有NULL引用，但有NULL指针。

有多级指针，但是没有多级引用。


